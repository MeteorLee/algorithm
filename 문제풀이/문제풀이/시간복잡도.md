# 시간 복잡도

## 시간 복잡도란

입력 크기와 알고리즘간의 관계

- 알고리즘의 복잡도를 나태는 지표 중 하나
- 입력 크기에 대해 프로그램의 동작 시간을 가늠해볼 수 있는 수단
- Big-O(최악) / Big-Omega(최선) / Big-Theta(평균) 와 같은 표기법이 존재
  - 코딩 테스트에서는 Big-O만을 신경써도 무방
  - 입력 데이터들 중에서 가장 최악의 경우를 포함한 시간 상한선


## 코딩테스트에서 시간 복잡도

- 현실에서 프로그램 동작 시간은 환경적 요소에 따라 달라진다.
- 보편적인 코딩 테스트에서는 문제마다 시간 제한이 주어짐
  - 시간 제한이 1초면 최악의 케이스에서도 해당 시간내에 답을 구할 수 있어야함
  - 시간 제한 내 프로그램이 종료되지 않으면 시간 초과를 받게 된다.
- 편의상 1초에 약 1억 번 연산을 기준으로 소요시간을 가늠할 수 있다.
  - 상수/최적화 등에 따라서 시간복잡도가 1천만밖에 안되더라도 1초를 넘기거나,
  - 시간복잡도가 1억이 넘어도 1초안에 실행될 수 있다.
  - 절대적 기준이 아닌 상대적 지표다.
- 적합한 알고리즘을 선택하는 기준이 된다.
  - 올바른 정답을 구하는 알고리즘은 여러개일 수 있다.
    - 시간이 넉넉하다면 구현이 쉬운 방법을 택할 수 있다.
    - 시간이 제한된다면 시간/메모리상으로 효율적인 방법을 택해야 하는 경우가 있다.

## Java의 추가 시간

- 같은 알고리즘을 구현했어도 언어마다 동작 시간이 다를 수 있다.
- 대부분의 시간/메모리 제한은 C/C++ 계열 언어 기준
- Java는 컴파일 방식으로만 동작하는 언어보다는 느린 편
- 응시 언어가 여러가지인 경우 각 언어의 통과를 보장하기 위해 보정값이 적용될 수 있다.
  - 보장 안되는 경우도 있다.

## N의 대략적인 시간

| N의 범위                        | 시간 복잡도                      |
|------------------------------|-----------------------------|
| N <= 10 ~ 11                 | O(N!)                       |
| N <= 24 ~ 25                 | O(N * N * N)                |
| N <= 300 ~ 500               | O(N * N)                    |
| N <= 50000 ~ 100000          | O(N * root(N))              |
| N <= 100000 ~ 1000000        | O(N * log(N)) (log의 아랫값은 2) |
| N <= 100000000               | O(N)                        |
| N개의 데이터가 입력이 아닌 범위 등으로 주어질 때 | O(root(N)), O(log(N)), O(1) |

- 참고 지표일 뿐이므로 정확한 것이 아님
- 시간 복잡도가 약간 벗어나더라도 실행되는 경우도 있음
- 외우지 않아도 1억 = 1초로 생각하고 계산을 하면된다.